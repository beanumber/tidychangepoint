---
output: github_document
---

# tidychangepoint

  <!-- badges: start -->
  [![R-CMD-check](https://github.com/beanumber/tidychangepoint/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/beanumber/tidychangepoint/actions/workflows/R-CMD-check.yaml)
  <!-- badges: end -->

## Usage

```{r, eval=FALSE}
remotes::install_github("beanumber/tidychangepoint")
```

```{r, message=FALSE}
library(tidychangepoint)
```

## Tidy methods for changepoint analysis

Consider the following time series:

```{r rlnorm-plot}
plot(as.ts(DataCPSim))
```

`tidychangepoint` allows you to use any number of algorithms for detecting changepoints in univariate time series with a common, `tidyverse`-compliant interface. 
The `segment()` function takes a numeric vector that is coercible into a `ts` object, and a string indicating the algorithm you wish you use. 
`segment()` always returns a `tidycpt` object. 

```{r}
cpts <- segment(DataCPSim, method = "pelt")
class(cpts)
```

Various methods are available for `tidycpt` objects. 
For example, `as.ts()` returns the original data as `ts` object, and `changepoints()` returns the set of changepoints. 

```{r}
changepoints(cpts)
```

### `broom` Interface

`tidychangepoint` follows the design interface of the `broom` package. 
Therefore, `augment()`, `tidy()` and `glance()` methods exists for `tidycpt` objects. 

- `augment()` returns a `tsibble` that is grouped according to the regions defined by the changepoints. 

```{r}
augment(cpts)
```

- `tidy()` returns a `tbl` that provides summary statistics for each region

```{r}
tidy(cpts)
```

- `glance()` returns a `tbl` that provides summary statistics for the model fit. 

```{r}
glance(cpts)
```

### Other methods

The `plot()` method leverages `ggplot2` to provide an informative plot. 

```{r pelt-plot}
plot(cpts)
```

The `diagnose()` function shows the empirical cumulative distribution of the exceedances of the time series, as well as how that distribution is modeled as a non-homogeneous Poisson process. 

```{r diagnose}
diagnose(cpts)
```



## Algorithms

### From `changepoint`

The `segment()` function passes argument to the `cpt.meanvar()` function from the `changepoint` package, and stores the resulting `cpt` object as its `segmenter` object. 

```{r changepoint, message=FALSE}
x <- changepoint::cpt.meanvar(DataCPSim, method = "PELT")
identical(x, cpts$segmenter)
```

### Naive methods

`segment()` includes three options for computing changepoints using naive methods, all of which return `lm` objects:

- `method = "null"`: returns null model with no changepoints

```{r null-plot}
DataCPSim |>
  segment(method = "null") |>
  diagnose()
```

- `method = "manual"`: returns a model with changepoints specified manually using the `cpts` argument

```{r manual-plot}
DataCPSim |>
  segment(method = "manual", cpts = c(365, 826)) |>
  diagnose()
```

- `method = "single-best"`: returns the model with at most one changepoint that minimizes the log-likelihood

```{r amoc-plot}
DataCPSim |>
  segment(method = "single-best") |>
  diagnose()
```

- `method = "random"`: returns the best model from a random collection

```{r random-plot}
DataCPSim |>
  segment(method = "random", num_generations = 20) |>
  diagnose()
```

### Genetic BMDL

- `method = "gbmdl"`: implements the Genetic BMDL heuristic

```{r gbmdl-tidyplot}
x <- DataCPSim |>
  segment(method = "gbmdl", num_generations = 5)
changepoints(x)
diagnose(x)
```

Diagnostic plots are also available. 

```{r plot-gbmdl}
plot(x$segmenter)
```

```{r diagnostic}
diagnose(x$segmenter)
```


## Citation

```{r}
citation("tidychangepoint")
```

